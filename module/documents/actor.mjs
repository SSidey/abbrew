import { mergeActorWounds } from "../helpers/combat.mjs";
import { applyOperator, getOrderForOperator } from "../helpers/operators.mjs";
import { applySkillEffects, handleSkillActivate, isSkillBlocked, mergeModifiers, parseModifierFieldValue, reduceParsedModifiers } from "../helpers/skill.mjs";
import { getAttackerAdvantageGuardResult, getAttackerAdvantageRiskResult, getDefenderAdvantageGuardResult, getDefenderAdvantageRiskResult } from "../helpers/trainedSkills.mjs";
import { compareModifierIndices, getObjectValueByStringPath } from "../helpers/utils.mjs";
import { FINISHERS } from "../static/finishers.mjs";

/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export default class AbbrewActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
    super.prepareBaseData();
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't 
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    super.prepareDerivedData();
    const actorData = this;
    const flags = actorData.flags.abbrew || {};
  }

  /**
   * 
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic 
   * approach is useful when you have actors & items that share a parent Document, 
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
  }

  getEffectBySkillId(skillId) {
    return this.effects.find(e => e.flags?.abbrew?.skill?.trackDuration === skillId);
  }

  async takeActionUpdates(data) {
    const updates = {};
    data.targetUpdates.forEach(update => {
      const current = getObjectValueByStringPath(this, update.path);
      let updatedValue = current;
      if (update && update.update.length > 0) {
        updatedValue = mergeModifiers(update.update.map(u => ({ value: reduceParsedModifiers(parseModifierFieldValue(u.values, this, this)), operator: u.operator })).flat(), current);
        updates[update.path] = updatedValue;
      }
    });

    if (Object.keys(updates).length > 0) {
      await this.update(updates);
    }

    // TODO: Report on the result?
    return updates;
  }

  async takeActionWounds(data) {
    if (data.targetWounds.length > 0) {
      const currentWounds = this.system.wounds;
      const updateWounds = Object.entries(
        data.targetWounds.map(w => ({ ...w, value: reduceParsedModifiers(parseModifierFieldValue(w.value, this, this)), index: getOrderForOperator(w.operator) })).sort(getOrderForOperator)
          .reduce((result, wound) => {
            result[wound.type] = applyOperator((result[wound.type] ?? 0), wound.value, wound.operator);

            return result;
          }, currentWounds)).map(e => ({ type: e[0], value: e[1] })).filter(w => w.value > 0);
      await this.update({ "system.wounds": updateWounds });
    }
  }

  async takeActionResources(data) {
    if (data.targetResources.length > 0) {
      const baseResources = this.system.resources.values.reduce((result, resource) => { result[resource.id] = resource.value; return result; }, {});
      const resourceModifiers = data.targetResources.map(r => ({ id: r.id, operator: r.operator, value: reduceParsedModifiers(parseModifierFieldValue(r.value, this, this)) }));
      const updateResources = Object.entries(resourceModifiers.reduce((result, resource) => {
        const id = resource.id;
        if (id in baseResources) {
          result[id] = Math.max(0, Math.min(baseResources[id] + resource.value, this.system.resources.owned.find(r => r.id === id).max));
        }

        return result;
      }, baseResources)).map(e => ({ id: e[0], value: e[1] }));

      await this.update({ "system.resources.values": updateResources });
    }
  }

  async takeDamage(rolls, data, action) {
    Hooks.call('actorTakesDamage', this);
    let guard = this.system.defense.guard.value;
    let risk = this.system.defense.risk.raw;
    const inflexibility = this.system.defense.inflexibility.raw;

    const attackingActorParryCounter = data.attackerSkillTraining.find(st => st.type === "parryCounter")?.value ?? 0;
    const attackingActorFeint = data.attackerSkillTraining.find(st => st.type === "feint")?.value ?? 0;

    //TODO: Tidy this up
    await this.setFlag("abbrew", "combat.damage.lastReceived", data.damage);
    await this.setFlag("abbrew", "combat.damage.roundReceived", this.mergeDamageTakenForRound(data.damage));
    let damage = this.applyModifiersToDamage(data);
    const updateRisk = this.calculateRisk(damage, guard, risk, inflexibility, data.isFeint, data.isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
    let overFlow = updateRisk > 100 ? updateRisk - 100 : 0;


    const updates = { "system.defense.guard.value": await this.calculateGuard(damage + overFlow, guard, data.isFeint, data.isStrongAttack, action, attackingActorParryCounter, attackingActorFeint), "system.defense.risk.raw": updateRisk };
    await this.update(updates);
    await this.renderAttackResultCard(data, action);
    await this.activateDamageTakenSkill();
    await this.handleSkillsGrantedOnAccept(data);
    return this;
  }

  async handleSkillsGrantedOnAccept(data) {
    data.skillsGrantedOnAccept.forEach(async s => {
      const skill = await fromUuid(s.sourceId);
      if (skill) {
        await Item.create(skill, { parent: this });
      }
    });
  }

  async activateDamageTakenSkill(damage) {
    this.items.filter(i => i.type === "skill").filter(s => s.system.activateOnDamageAccept).forEach(async s => {
      await handleSkillActivate(this, s, false);
    })
  }

  async takeEffect(data, rolls, action) {
    await this.takeActionUpdates(data);
    await this.takeActionWounds(data);
    await this.takeActionResources(data);
  }

  async takeAttack(data, rolls, action) {
    await this.takeEffect(data, rolls, action);
    await this.takeDamage(rolls, data, action);
  }

  async takeFinisher(rolls, data, finisherType) {
    if (data.totalSuccesses < 1 && !this.statuses.has('offGuard')) {
      await this.sendFinisherToChat();
      return;
    }

    await this.takeEffect(data, rolls, action);
    await this.takeDamage(rolls, data, "finisher");

    const risk = this.system.defense.risk.raw;
    const totalRisk = this.applyModifiersToRisk(rolls, data, finisherType);
    let finisherCost = 0;
    let finisher = null;
    const uniqueFinisher = data.finisher ? Object.values(data.finisher)[0] : null;
    if (uniqueFinisher?.type && uniqueFinisher?.text) {
      finisherCost = Object.keys(data.finisher)[0];
      const finisherConstruct = data.finisher;
      this.getFinisherCost(finisherConstruct, totalRisk, data.attackProfile);
      finisher = this.getFinisher(finisherConstruct, finisherCost);
    } else {
      const availableFinishers = this.getAvailableFinishersForDamageType(finisherType);
      finisherCost = this.getFinisherCost(availableFinishers, totalRisk, data.attackProfile);
      finisher = this.getFinisher(availableFinishers, finisherCost);
    }
    await this.sendFinisherToChat(finisher, finisherCost);
    if (finisher) {
      return await this.applyFinisher(risk, finisher, finisherCost);
    }
  }

  mergeDamageTakenForRound(damage) {
    const lastRoundReceived = this.flags.abbrew.combat.damage.lastRoundReceived ?? [];
    const totalRoundReceivedDamage = Object.entries([...lastRoundReceived, ...damage].reduce((result, damage) => {
      if (damage.damageType in result) {
        result[damage.damageType] += damage.value;
      } else {
        result[damage.damageType] = damage.value;
      }

      return result;
    }, {})).map(e => ({ damageType: e[0], value: e[1] }));

    return totalRoundReceivedDamage;
  }

  applyModifiersToRisk(rolls, data, finisherType) {
    let successes = 0;
    if (this.system.defense.protection[finisherType].immunity > 0) {
      return successes;
    }

    successes += data.totalSuccesses;
    successes += this.system.defense.risk.value;
    successes -= this.system.defense.inflexibility.resistance.value;
    successes -= Math.max(0, this.system.defense.protection[finisherType].resistance - data.damage.find(d => d.damageType === finisherType)?.penetration ?? 0);
    successes += this.system.defense.protection[finisherType].weakness;
    // TODO: Size Diff
    // TODO: Tier Diff
    // TODO: Lethal Diff
    // TODO: Material Tier Diff
    return successes;
  }

  getAvailableFinishersForDamageType(finisherType) {
    return finisherType in FINISHERS ? FINISHERS[finisherType] : FINISHERS['untyped'];
  }

  getFinisherCost(availableFinishers, risk, attackProfile) {
    const viableRisk = Math.min(risk, attackProfile.finisherLimit);
    const keys = Object.keys(availableFinishers);
    const cost = keys.filter((value) => value <= viableRisk).pop();
    if (cost) {
      return cost;
    }

    return 0;
  }

  getFinisher(availableFinishers, finisherKey) {
    return availableFinishers[finisherKey];
  }

  // TODO: Move to another module?
  async sendFinisherToChat(finisher, finisherCost) {
    const templateData = {
      finisherCost,
      finisher,
      actor: this,
      tokenId: this.token?.uuid || null,
    };

    const html = await renderTemplate("systems/abbrew/templates/chat/finisher-card.hbs", templateData);

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });
    // const rollMode = game.settings.get('core', 'rollMode');
    const label = finisher ? `${finisher.name}` : "No available finisher";
    ChatMessage.create({
      speaker: speaker,
      // rollMode: rollMode,
      flavor: label,
      content: html,
      flags: { data: { finisher, finisherCost } }
    });
  }

  async applyFinisher(risk, finisher, finisherCost) {
    const updates = { "system.wounds": mergeActorWounds(this, finisher.wounds), "system.defense.risk.raw": this.reduceRiskForFinisher(risk, finisherCost) };
    await this.update(updates);
    return this;
  }

  reduceRiskForFinisher(risk, finisherCost) {
    return risk - (finisherCost * 10);
  }

  applyModifiersToDamage(data) {
    let rollSuccesses = data.totalSuccesses;
    return data.damage.reduce((result, d) => {
      const protection = this.system.defense.protection[d.damageType];
      if (protection.immunity > 0) {
        return result;
      }

      const damageTypeSuccesses = rollSuccesses;

      if (damageTypeSuccesses < 0) {
        return result;
      }

      let multiplierSelector = Math.max(0, protection.resistance - d.penetration) - protection.weakness;
      let multiplier = 1;
      if (multiplierSelector > 0) {
        multiplier = 0.5;
      } else if (multiplierSelector < 0) {
        multiplier = 2;
      }

      const dmg = Math.floor(d.value * multiplier);

      return result += dmg;
    }, 0);
  }

  async calculateGuard(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    return guard - this.calculateGuardReduction(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
  }

  calculateGuardReduction(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    if (this.noneResult(isFeint, action)) {
      return 0;
    }

    if (isStrongAttack) {
      return 0 + damage;
    }

    if (this.attackerGainsAdvantage(isFeint, action)) {
      return getAttackerAdvantageGuardResult(this.system.skillTraining.find(st => st.type === "feintCounter")?.value ?? 0, attackingActorFeint, damage);
    }

    if (this.defenderGainsAdvantage(isFeint, action)) {
      return getDefenderAdvantageGuardResult(this.system.skillTraining.find(st => st.type === "parry")?.value ?? 0, attackingActorParryCounter, damage);
    }

    return 0 + damage;
  }

  calculateRisk(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    return risk + this.calculateRiskIncrease(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
  }

  calculateRiskIncrease(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    if (this.noneResult(isFeint, action)) {
      return 0;
    }

    if (isStrongAttack) {
      return guard > 0 ? Math.min(damage, inflexibility) : damage;
    }

    if (this.attackerGainsAdvantage(isFeint, action)) {
      return getAttackerAdvantageRiskResult(this.system.skillTraining.find(st => st.type === "feintCounter")?.value ?? 0, attackingActorFeint, damage, inflexibility, guard);
    }

    if (this.defenderGainsAdvantage(isFeint, action)) {
      return getDefenderAdvantageRiskResult(this.system.skillTraining.find(st => st.type === "parry")?.value ?? 0, attackingActorParryCounter, damage, inflexibility, guard);
    }

    return guard > 0 ? Math.min(damage, inflexibility) : damage;
  }

  defenderGainsAdvantage(isFeint, action) {
    return isFeint === false && action === 'parry';
  }

  attackerGainsAdvantage(isFeint, action) {
    return isFeint === true && action === 'parry';
  }

  noneResult(isFeint, action) {
    return isFeint === true && action === 'damage'
  }

  async renderAttackResultCard(data, action) {
    const attackerAdvantage = this.attackerGainsAdvantage(data.isFeint, action);
    const defenderAdvantage = this.defenderGainsAdvantage(data.isFeint, action);
    const noneResult = this.noneResult(data.isFeint, action);

    const templateData = {
      attackerAdvantage,
      defenderAdvantage,
      noneResult,
      actor: this,
      defendingActor: this,
      attackingActor: data.attackingActor,
      tokenId: this.token?.uuid || null,
    };

    const html = await renderTemplate("systems/abbrew/templates/chat/attack-result-card.hbs", templateData);

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });

    ChatMessage.create({
      speaker: speaker,
      // rollMode: rollMode,
      // flavor: label,
      content: html,
      flags: { /* data: { finisher, finisherCost } */ }
    });
  }

  getActorWornArmour() {
    const armour = this.items.filter(i => i.type === 'armour');
    return armour.filter(a => a.system.equipState === 'worn')
  }

  getActorHeldItems() {
    return this.items.filter(a => a.system.equipType === 'held').filter(a => a.system.equipState.startsWith('held'));
  }

  getActorAnatomy() {
    return this.items.filter(i => i.type === 'anatomy');
  }

  doesActorHaveSkillTrait(feature, subFeature, effect, data) {
    return this.items.filter(i => i.system.skillTraits).flatMap(i => JSON.parse(i.system.skillTraits)).some(t => t.feature === feature && t.subFeature === subFeature && t.effect === effect && t.data === data) ?? false;
  }

  async acceptWound(type, value) {
    const updates = { "system.wounds": mergeActorWounds(this, [{ type, value }]) };
    await this.update(updates);
    return this;
  }

  async acceptBackground(background) {
    const name = background.name;
    const image = background.img;
    const description = background.system.description;
    const attributeIncreases = Object.entries(background.system.attributes).filter(atr => atr[1].value > 0).reduce((result, attribute) => result.concat(Array(attribute[1].value).fill(attribute[0])), []);
    for (const index in attributeIncreases) {
      const system = {
        description,
        attributeIncrease: attributeIncreases[index],
        skillType: "background"
      };
      const itemData = {
        name,
        img: image,
        type: 'skill',
        system
      };
      await Item.create(itemData, { parent: this });
    }
  }

  async acceptCreatureForm(creatureForm) {
    const anatomy = await Promise.all(creatureForm.system.anatomy.map(async a => await fromUuid(a.sourceId)));
    for (const index in anatomy) {
      await Item.create(anatomy[index], { parent: this });

      const weapons = await Promise.all(anatomy[index].system.naturalWeapons.map(async w => await fromUuid(w.sourceId)));
      for (const weaponIndex in weapons) {
        await Item.create(weapons[weaponIndex], { parent: this });
      }
    }
  }

  async acceptSkillDeck(skillDeck) {
    const skills = await Promise.all(skillDeck.system.skills.granted.map(async s => await fromUuid(s.sourceId)));
    for (const index in skills) {
      await Item.create(skills[index], { parent: this })
    }
  }

  async acceptAnatomy(anatomy) {
    const naturalWeapons = await Promise.all(anatomy.system.naturalWeapons.map(async w => await fromUuid(w.sourceId)));
    for (const index in naturalWeapons) {
      await Item.create(naturalWeapons[index], { parent: this })
    }
  }

  async canActorUseActions(actions) {
    if (!game.combat && actions <= 5) {
      return true;
    }

    let remainingActions = this.system.actions;
    if (actions > remainingActions) {
      ui.notifications.info("You do not have enough actions to do that.");
      return false;
    }

    await this.update({ "system.actions": remainingActions -= actions });
    return true;
  }

  async handleDeleteActiveEffect(effect) {
    const itemId = effect?.flags?.abbrew?.skill?.trackDuration;
    if (itemId) {
      const item = this.items.find(i => i._id === itemId)
      if (item) {
        if (item.system.applyOnExpiry && item.isOwner) {
          await applySkillEffects(this, item);
        }
        await item.update({ "system.action.charges.value": 0 })
        if (item.system.skillType === "temporary") {
          await item.delete();
        }
      }
    }

    const activeSkillsWithDuration = this.effects.toObject().filter(e => e.flags?.abbrew?.skill?.type === "standalone").map(e => e.flags.abbrew.skill.trackDuration);
    const queuedSkillsWithDuration = this.effects.toObject().filter(e => e.flags?.abbrew?.skill?.type === "synergy").map(e => e.flags.abbrew.skill.trackDuration);
    await this.update({ "system.activeSkills": activeSkillsWithDuration, "system.queuedSkills": queuedSkillsWithDuration });
  }

  doesActorHaveSkillDiscord(skillName) {
    const skill = this.items.find(i => i.name === skillName);
    if (skill) {
      return isSkillBlocked(this, skill);
    }

    return false;
  }

  async handleResourceFill(id, capacity) {
    const resourceValues = this.system.resources.values;
    resourceValues.find(r => r.id === id).value += capacity;
    await this.update({ "system.resources.values": resourceValues });
  }
}