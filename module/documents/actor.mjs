import { mergeActorWounds } from "../helpers/combat.mjs";
import { isSkillBlocked } from "../helpers/skill.mjs";
import { getAttackerAdvantageGuardResult, getAttackerAdvantageRiskResult, getDefenderAdvantageGuardResult, getDefenderAdvantageRiskResult } from "../helpers/trainedSkills.mjs";
import { FINISHERS } from "../static/finishers.mjs";

/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export default class AbbrewActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
    super.prepareBaseData();
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't 
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    super.prepareDerivedData();
    const actorData = this;
    const flags = actorData.flags.abbrew || {};
  }

  /**
   * 
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic 
   * approach is useful when you have actors & items that share a parent Document, 
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
  }

  async takeDamage(rolls, data, action) {
    Hooks.call('actorTakesDamage', this);
    let guard = this.system.defense.guard.value;
    let risk = this.system.defense.risk.raw;
    const inflexibility = this.system.defense.inflexibility.raw;

    const attackingActorParryCounter = data.attackerSkillTraining.find(st => st.type === "parryCounter")?.value ?? 0;
    const attackingActorFeint = data.attackerSkillTraining.find(st => st.type === "feint")?.value ?? 0;

    //TODO: Tidy this up
    let damage = this.applyModifiersToDamage(rolls, data, action);
    const updateRisk = this.calculateRisk(damage, guard, risk, inflexibility, data.isFeint, data.isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
    let overFlow = updateRisk > 100 ? updateRisk - 100 : 0;


    const updates = { "system.defense.guard.value": await this.calculateGuard(damage + overFlow, guard, data.isFeint, data.isStrongAttack, action, attackingActorParryCounter, attackingActorFeint), "system.defense.risk.raw": updateRisk };
    await this.update(updates);
    await this.renderAttackResultCard(data, action);
    return this;
  }

  async takeFinisher(rolls, data) {
    if (data.totalSuccesses < 1 && !this.statuses.has('offGuard')) {
      await this.sendFinisherToChat();
      return;
    }

    await this.takeDamage(rolls, data);

    const risk = this.system.defense.risk.raw;
    const totalRisk = this.applyModifiersToRisk(rolls, data);
    const availableFinishers = this.getAvailableFinishersForDamageType(data);
    const finisherCost = this.getFinisherCost(availableFinishers, totalRisk, data.attackProfile);
    const finisher = this.getFinisher(availableFinishers, finisherCost);
    await this.sendFinisherToChat(finisher, finisherCost);
    if (finisher) {
      return await this.applyFinisher(risk, finisher, finisherCost);
    }
  }

  applyModifiersToRisk(rolls, data) {
    let successes = 0;
    successes += data.totalSuccesses;
    successes += this.system.defense.risk.value;
    successes -= this.system.defense.inflexibility.resistance.value;
    successes += data.damage.map(d => this.system.defense.protection.find(w => w.type === d.damageType)).reduce((result, p) => result += p?.weakness ?? 0, 0);
    successes -= data.damage.map(d => this.system.defense.protection.find(w => w.type === d.damageType)).reduce((result, p) => result += p?.resistance ?? 0, 0);
    // TODO: Size Diff
    // TODO: Tier Diff
    // TODO: Lethal Diff
    // TODO: Material Tier Diff
    return successes;
  }

  getAvailableFinishersForDamageType(data) {
    // TODO: Only looking at main damage type?
    return data.damage[0].damageType in FINISHERS ? FINISHERS[data.damage[0].damageType] : FINISHERS['physical'];
  }

  getFinisherCost(availableFinishers, risk, attackProfile) {
    const viableRisk = Math.min(risk, attackProfile.finisherLimit);
    const keys = Object.keys(availableFinishers);
    const cost = keys.filter((value) => value <= viableRisk).pop();
    if (cost) {
      return cost;
    }

    return 0;
  }

  getFinisher(availableFinishers, finisherKey) {
    return availableFinishers[finisherKey];
  }

  // TODO: Move to another module?
  async sendFinisherToChat(finisher, finisherCost) {
    const templateData = {
      finisherCost,
      finisher,
      actor: this,
      tokenId: this.token?.uuid || null,
    };

    const html = await renderTemplate("systems/abbrew/templates/chat/finisher-card.hbs", templateData);

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });
    // const rollMode = game.settings.get('core', 'rollMode');
    const label = finisher ? `${finisher.name}` : "No available finisher";
    ChatMessage.create({
      speaker: speaker,
      // rollMode: rollMode,
      flavor: label,
      content: html,
      flags: { data: { finisher, finisherCost } }
    });
  }

  async applyFinisher(risk, finisher, finisherCost) {
    const updates = { "system.wounds": mergeActorWounds(this, finisher.wounds), "system.defense.risk.raw": this.reduceRiskForFinisher(risk, finisherCost) };
    await this.update(updates);
    return this;
  }

  reduceRiskForFinisher(risk, finisherCost) {
    return risk - (finisherCost * 10);
  }

  applyModifiersToDamage(rolls, data) {
    let rollSuccesses = data.totalSuccesses;
    return data.damage.reduce((result, d) => {
      // TODO: Enable new DR types
      const protection = /* this.system.defense.protection.some(dr => dr.type === d.damageType) ? this.system.defense.protection.filter(dr => dr.type === d.damageType)[0] : */ { immunity: 0, resistance: 0, weakness: 0 };
      if (protection.immunity > 0) {
        return result;
      }

      const damageTypeSuccesses = rollSuccesses;

      if (damageTypeSuccesses < 0) {
        return result;
      }

      const dmg = d.value;

      return result += dmg;
    }, 0);
  }

  async calculateGuard(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    return guard - this.calculateGuardReduction(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
  }

  calculateGuardReduction(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    if (this.noneResult(isFeint, action)) {
      return 0;
    }

    if (isStrongAttack) {
      return 0 + damage;
    }

    if (this.attackerGainsAdvantage(isFeint, action)) {
      return getAttackerAdvantageGuardResult(this.system.skillTraining.find(st => st.type === "feintCounter")?.value ?? 0, attackingActorFeint, damage);
    }

    if (this.defenderGainsAdvantage(isFeint, action)) {
      return getDefenderAdvantageGuardResult(this.system.skillTraining.find(st => st.type === "parry")?.value ?? 0, attackingActorParryCounter, damage);
    }

    return 0 + damage;
  }

  calculateRisk(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    return risk + this.calculateRiskIncrease(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
  }

  calculateRiskIncrease(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    if (this.noneResult(isFeint, action)) {
      return 0;
    }

    if (isStrongAttack) {
      return Math.min(damage, inflexibility);
    }

    if (this.attackerGainsAdvantage(isFeint, action)) {
      return getAttackerAdvantageRiskResult(this.system.skillTraining.find(st => st.type === "feintCounter")?.value ?? 0, attackingActorFeint, damage, inflexibility);
    }

    if (this.defenderGainsAdvantage(isFeint, action)) {
      return getDefenderAdvantageRiskResult(this.system.skillTraining.find(st => st.type === "parry")?.value ?? 0, attackingActorParryCounter, damage, inflexibility);
    }

    return Math.min(damage, inflexibility);
  }

  defenderGainsAdvantage(isFeint, action) {
    return isFeint === false && action === 'parry';
  }

  attackerGainsAdvantage(isFeint, action) {
    return isFeint === true && action === 'parry';
  }

  noneResult(isFeint, action) {
    return isFeint === true && action === 'damage'
  }

  async renderAttackResultCard(data, action) {
    const attackerAdvantage = this.attackerGainsAdvantage(data.isFeint, action);
    const defenderAdvantage = this.defenderGainsAdvantage(data.isFeint, action);
    const noneResult = this.noneResult(data.isFeint, action);

    const templateData = {
      attackerAdvantage,
      defenderAdvantage,
      noneResult,
      actor: this,
      defendingActor: this,
      attackingActor: data.attackingActor,
      tokenId: this.token?.uuid || null,
    };

    const html = await renderTemplate("systems/abbrew/templates/chat/attack-result-card.hbs", templateData);

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });

    ChatMessage.create({
      speaker: speaker,
      // rollMode: rollMode,
      // flavor: label,
      content: html,
      flags: { /* data: { finisher, finisherCost } */ }
    });
  }

  getActorWornArmour() {
    const armour = this.items.filter(i => i.type === 'armour');
    return armour.filter(a => a.system.equipState === 'worn')
  }

  getActorHeldItems() {
    return this.items.filter(a => a.system.equipType === 'held').filter(a => a.system.equipState.startsWith('held'));
  }

  getActorAnatomy() {
    return this.items.filter(i => i.type === 'anatomy');
  }

  doesActorHaveSkillTrait(feature, subFeature, effect, data) {
    return this.items.filter(i => i.system.skillTraits).flatMap(i => JSON.parse(i.system.skillTraits)).some(t => t.feature === feature && t.subFeature === subFeature && t.effect === effect && t.data === data) ?? false;
  }

  async acceptWound(type, value) {
    const updates = { "system.wounds": mergeActorWounds(this, [{ type, value }]) };
    await this.update(updates);
    return this;
  }

  async acceptBackground(background) {
    const name = background.name;
    const image = background.img;
    const description = background.system.description;
    const attributeIncreases = Object.entries(background.system.attributes).filter(atr => atr[1].value > 0).reduce((result, attribute) => result.concat(Array(attribute[1].value).fill(attribute[0])), []);
    for (const index in attributeIncreases) {
      const system = {
        description,
        attributeIncrease: attributeIncreases[index],
        skillType: "background"
      };
      const itemData = {
        name,
        img: image,
        type: 'skill',
        system
      };
      await Item.create(itemData, { parent: this });
    }
  }

  async acceptCreatureForm(creatureForm) {
    const anatomy = creatureForm.system.anatomy.map(a => game.items.get(a.id));
    for (const index in anatomy) {
      await Item.create(anatomy[index], { parent: this });

      const weapons = anatomy[index].system.naturalWeapons.map(w => game.items.get(w.id));
      for (const weaponIndex in weapons) {
        await Item.create(weapons[weaponIndex], { parent: this });
      }
    }
  }

  async acceptSkillDeck(skillDeck) {
    const skills = skillDeck.system.skills.map(s => game.items.get(s.id));
    for (const index in skills) {
      await Item.create(skills[index], { parent: this })
    }
  }

  async acceptAnatomy(anatomy) {
    const naturalWeapons = anatomy.system.naturalWeapons.map(w => game.items.get(w.id));
    for (const index in naturalWeapons) {
      await Item.create(naturalWeapons[index], { parent: this })
    }
  }

  async canActorUseActions(actions) {
    if (!game.combat && actions <= 5) {
      return true;
    }

    let remainingActions = this.system.actions;
    if (actions > remainingActions) {
      ui.notifications.info("You do not have enough actions to do that.");
      return false;
    }

    await this.update({ "system.actions": remainingActions -= actions });
    return true;
  }

  async handleDeleteActiveEffect(effect) {
    const itemId = effect?.flags?.abbrew?.skill?.trackDuration;
    if (itemId) {
      const item = this.items.find(i => i._id === itemId)
      await item.update({ "system.action.charges.value": 0 })
      if (item.system.skillType === "temporary") {
        await item.delete();
      }
    }
    const activeSkillsWithDuration = this.effects.toObject().filter(e => e.flags?.abbrew?.skill?.type === "standalone").map(e => e.flags.abbrew.skill.trackDuration);
    const queuedSkillsWithDuration = this.effects.toObject().filter(e => e.flags?.abbrew?.skill?.type === "synergy").map(e => e.flags.abbrew.skill.trackDuration);
    await this.update({ "system.activeSkills": activeSkillsWithDuration, "system.queuedSkills": queuedSkillsWithDuration });
  }

  doesActorHaveSkillDiscord(skillName) {
    const skill = this.items.find(i => i.name === skillName);
    if (skill) {
      return isSkillBlocked(this, skill);
    }

    return false;
  }
}