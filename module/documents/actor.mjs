import { mergeActorWounds, renderLostResolveCard, setActorToOffGuard, checkActorFatalWounds } from "../helpers/combat.mjs";
import { FINISHERS } from "../static/finishers.mjs";

/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export default class AbbrewActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    console.log('documentPrepareData');
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    console.log('documentPrepareBaseData');
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't 
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    console.log('documentPrepareDerivedData');
    const actorData = this;
    const flags = actorData.flags.abbrew || {};
  }

  /**
   * 
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic 
   * approach is useful when you have actors & items that share a parent Document, 
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
  }

  async takeDamage(rolls, data, action) {
    Hooks.call('actorTakesDamage', this);
    let guard = this.system.defense.guard.value;
    let risk = this.system.defense.risk.raw;
    const inflexibility = this.system.defense.inflexibility.raw;

    const damage = this.applyModifiersToDamage(rolls, data, action);

    const updates = { "system.defense.guard.value": await this.calculateGuard(damage, guard, data.isFeint, action), "system.defense.risk.raw": this.calculateRisk(damage, guard, risk, inflexibility, data.isFeint, action) };
    await this.update(updates);
    await this.renderAttackResultCard(data, action);
    return this;
  }

  async takeFinisher(rolls, data) {
    if (data.totalSuccesses < 1 && !this.statuses.has('offGuard')) {
      // TODO: Report to chat that the finisher failed for unable to use finisher?
      console.log('No finisher was possible');
      return;
    }

    const risk = this.system.defense.risk.raw;
    console.log('Finisher');
    const totalRisk = this.applyModifiersToRisk(rolls, data);
    const availableFinishers = this.getAvailableFinishersForDamageType(data);
    const finisherCost = this.getFinisherCost(availableFinishers, totalRisk);
    const finisher = this.getFinisher(availableFinishers, finisherCost);
    console.log(finisher);
    if (finisher) {
      await this.sendFinisherToChat(finisher, finisherCost);
      return await this.applyFinisher(risk, finisher, finisherCost);
    }

    // TODO: Report to chat that the finisher failed for resistance?
  }

  applyModifiersToRisk(rolls, data) {
    const rollSuccesses = data.totalSuccesses;
    // Plate less guard, more risk reduction, leather more guard, less risk reduction
    // TODO: Size Diff
    // TODO: Tier Diff
    // TODO: Lethal Diff
    // TODO: Material Tier Diff
    return 0 + this.system.defense.risk.value + rollSuccesses - this.system.defense.inflexibility.resistance.value;
  }

  getAvailableFinishersForDamageType(data) {
    // TODO: Only looking at main damage type?
    return data.damage[0].damageType in FINISHERS ? FINISHERS[data.damage[0].damageType] : FINISHERS['general'];
  }

  getFinisherCost(availableFinishers, risk) {
    // TODO: Apply weapon size limit
    const keys = Object.keys(availableFinishers);
    const cost = keys.filter((value) => value <= risk).pop();
    if (cost) {
      return cost;
    }

    return 0;
  }

  getFinisher(availableFinishers, finisherKey) {
    return availableFinishers[finisherKey];
  }

  // TODO: Move to another module?
  async sendFinisherToChat(finisher, finisherCost) {
    const templateData = {
      finisherCost,
      finisher,
      actor: this,
      tokenId: this.token?.uuid || null,
    };

    const html = await renderTemplate("systems/abbrew/templates/chat/finisher-card.hbs", templateData);

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });
    // const rollMode = game.settings.get('core', 'rollMode');
    const label = `${finisher.name}`;
    ChatMessage.create({
      speaker: speaker,
      // rollMode: rollMode,
      flavor: label,
      content: html,
      flags: { data: { finisher, finisherCost } }
    });
  }

  async applyFinisher(risk, finisher, finisherCost) {
    const updates = { "system.wounds": mergeActorWounds(this, finisher.wounds), "system.defense.risk.raw": this.reduceRiskForFinisher(risk, finisherCost) };
    await this.update(updates);
    return this;
  }

  reduceRiskForFinisher(risk, finisherCost) {
    return risk - (finisherCost * 10);
  }

  applyModifiersToDamage(rolls, data) {
    let rollSuccesses = data.totalSuccesses;
    return data.damage.reduce((result, d) => {
      // TODO: Enable new DR types
      const protection = /* this.system.defense.protection.some(dr => dr.type === d.damageType) ? this.system.defense.protection.filter(dr => dr.type === d.damageType)[0] : */ { immunity: 0, resistance: 0, weakness: 0, value: 0 };
      if (protection.immunity > 0) {
        return result;
      }

      const firstRoll = rolls[0].dice[0].results[0].result ?? 0;
      // const dodge = this.system.defense.dodge.value;
      const damageTypeSuccesses = /* firstRoll > dodge ? */ rollSuccesses/*  + protection.weakness - protection.resistance : -1 */;

      if (damageTypeSuccesses < 0) {
        return result;
      }

      const dmg = /* damageTypeSuccesses == 0 ? Math.max(0, d.value - protection.value) : */ d.value;

      return result += dmg;
    }, 0);
  }

  async calculateGuard(damage, guard, isFeint, action) {
    let guardDamage = damage;
    if (this.defenderGainsAdvantage(isFeint, action)) {
      guardDamage = -10;
    }

    const guardUpdate = Math.max(0, guard - guardDamage);

    return guardUpdate;
  }

  calculateRisk(damage, guard, risk, inflexibility, isFeint, action) {
    let riskIncrease = guard > 0 ? Math.min(damage, inflexibility) : damage;
    if (this.attackerGainsAdvantage(isFeint, action)) {
      riskIncrease += damage;
    } else if (this.defenderGainsAdvantage()) {
      riskIncrease = 0;
    }

    return risk + riskIncrease;
  }

  defenderGainsAdvantage(isFeint, action) {
    return isFeint === false && action === 'parry';
  }

  attackerGainsAdvantage(isFeint, action) {
    return isFeint === true && action === 'parry';
  }

  async renderAttackResultCard(data, action) {
    const attackerAdvantage = this.attackerGainsAdvantage(data.isFeint, action);
    const defenderAdvantage = this.defenderGainsAdvantage(data.isFeint, action);

    if (attackerAdvantage || defenderAdvantage) {
      const templateData = {
        attackerAdvantage,
        defenderAdvantage,
        actor: this,
        defendingActor: this,
        attackingActor: data.attackingActor,
        tokenId: this.token?.uuid || null,
      };

      const html = await renderTemplate("systems/abbrew/templates/chat/attack-result-card.hbs", templateData);

      // Initialize chat data.
      const speaker = ChatMessage.getSpeaker({ actor: this.actor });

      ChatMessage.create({
        speaker: speaker,
        // rollMode: rollMode,
        // flavor: label,
        content: html,
        flags: { /* data: { finisher, finisherCost } */ }
      });
    }
  }

  getActorWornArmour() {
    const armour = this.items.filter(i => i.type === 'armour');
    return armour.filter(a => a.system.equipState === 'worn')
  }

  getActorHeldItems() {
    return this.items.filter(a => a.system.equipType === 'held').filter(a => a.system.equipState.startsWith('held'));
  }

  getActorAnatomy() {
    return this.items.filter(i => i.type === 'anatomy');
  }
}
