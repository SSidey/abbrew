import { mergeActorWounds } from "../helpers/combat.mjs";
import { applyFullyParsedModifiers, mergeModifierFields, reduceParsedModifiers } from "../helpers/modifierBuilderFieldHelpers.mjs";
import { handleSkillActivate, isSkillBlocked } from "../helpers/skills/skill-activation.mjs";
import { applySkillEffects } from "../helpers/skills/skill-application.mjs";
import { handleGrantedSkills, handleSkillsGrantedOnAccept } from "../helpers/skills/skill-grants.mjs";
import { getAttackerAdvantageGuardResult, getAttackerAdvantageRiskResult, getDefenderAdvantageGuardResult, getDefenderAdvantageRiskResult } from "../helpers/trainedSkills.mjs";
import { compareModifierIndices, doesNestedFieldExist, getObjectValueByStringPath } from "../helpers/utils.mjs";
import { FINISHERS } from "../static/finishers.mjs";

/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export default class AbbrewActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
    super.prepareBaseData();
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't 
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    super.prepareDerivedData();
    const actorData = this;
    const flags = actorData.flags.abbrew || {};
  }

  async _preUpdate(changed, options, userId) {
    if (doesNestedFieldExist(changed, "system.meta.size")) {
      if (!isNaN(changed.system.meta.size)) {
        const changeSize = parseFloat(changed.system.meta.size);
        const dimension = Object.values(CONFIG.ABBREW.size).find(s => s.value === changeSize).dimension;
        await this.token?.update({ "height": dimension, "width": dimension });
      }
    }
  }

  /**
   * @override
   **/
  applyActiveEffects() {
    const overrides = {};
    this.statuses.clear();

    // Organize non-disabled effects by their application priority
    const changes = [];
    this.allApplicableEffects().forEach(effect => {
      if (effect.active) {
        changes.push(...effect.changes.map((change, index) => {
          const c = foundry.utils.deepClone(change);
          c.effect = effect;
          c.priority = c.priority ?? (c.mode * 10);
          c.index = index;
          return c;
        }));
        for (const statusId of effect.statuses) this.statuses.add(statusId);
      }
    });
    changes.sort((a, b) => a.priority - b.priority);

    // Apply all changes
    changes.forEach(change => {
      if (change.key) {
        const changes = change.effect.apply(this, change);
        Object.assign(overrides, changes);
      }
    });

    // Expand the set of final overrides
    this.overrides = foundry.utils.expandObject(overrides);
  }

  /**
   * 
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic 
   * approach is useful when you have actors & items that share a parent Document, 
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
  }

  getEffectBySkillId(skillId) {
    return this.effects.find(e => e.flags?.abbrew?.skill?.trackDuration === skillId);
  }

  async takeActionUpdates(data) {
    if (!data.targetUpdates) {
      return;
    }

    let updates = {};

    data.targetUpdates.forEach(update => {
      const parsedUpdates = update.update;
      const lateModifiers = update.lateModifiers;
      const [lateUpdates,] = mergeModifierFields(lateModifiers, this);
      const fullUpdates = [...parsedUpdates, ...lateUpdates].sort(compareModifierIndices);
      const updateValue = applyFullyParsedModifiers(fullUpdates, this, update.path);

      updates = { ...updates, ...updateValue };
    });

    await this.update(updates);
    return updates;
  }

  async takeActionWounds(data) {
    if (!data.targetWounds || data.targetWounds.length === 0) {
      return;
    }

    const path = "system.wounds";
    let updates = {};
    let updateValues = [];

    data.targetWounds.forEach(w => {
      const parsedUpdates = w.update;
      const lateModifiers = w.lateModifiers;
      const [lateUpdates,] = mergeModifierFields(lateModifiers, this);
      const fullUpdates = [...parsedUpdates, ...lateUpdates].sort(compareModifierIndices);
      const updateValue = applyFullyParsedModifiers(fullUpdates, this, path, "type", w.type);

      updateValues = [...updateValues, updateValue[path]];
    });

    const fieldValue = getObjectValueByStringPath(this, path);

    let fullValue = [...updateValues, ...fieldValue].reduce((result, wound) => {
      if (!result.find(r => r.type === wound.type) && wound.value > 0) {
        result.push(wound);
      }

      return result;
    }, []);

    updates[path] = fullValue;
    await this.update(updates);
    return updates;
  }

  async takeActionResources(data) {
    if (!data.targetResources || data.targetResources.length === 0) {
      return;
    }

    const path = "system.resources.values";
    let updates = {};
    let updateValues = [];

    data.targetResources.forEach(r => {
      const parsedUpdates = r.update;
      const lateModifiers = r.lateModifiers;
      const [lateUpdates,] = mergeModifierFields(lateModifiers, this);
      const fullUpdates = [...parsedUpdates, ...lateUpdates].sort(compareModifierIndices);
      const updateValue = applyFullyParsedModifiers(fullUpdates, this, path, "id", r.type);

      updateValues = [...updateValues, updateValue[path]];
    });

    const fieldValue = getObjectValueByStringPath(this, path);

    let fullValue = [...updateValues, ...fieldValue].reduce((result, resource) => {
      if (!result.find(r => r.id === resource.id)) {
        result.push(resource);
      }

      return result;
    }, []);

    updates[path] = fullValue;
    await this.update(updates);
    return updates;
  }

  async takeDamage(data, action) {
    Hooks.call('actorTakesDamage', this);
    let guard = this.system.defense.guard.value;
    let risk = this.system.defense.risk.raw;
    const inflexibility = this.system.defense.inflexibility.raw;

    const attackingActorParryCounter = data.attackerSkillTraining.find(st => st.type === "parryCounter")?.value ?? 0;
    const attackingActorFeint = data.attackerSkillTraining.find(st => st.type === "feint")?.value ?? 0;

    //TODO: Tidy this up
    await this.setFlag("abbrew", "combat.damage.lastReceived", data.damage);
    await this.setFlag("abbrew", "combat.damage.roundReceived", this.mergeDamageTakenForRound(data.damage));
    let damage = this.applyModifiersToDamage(data);
    const updateRisk = this.calculateRisk(damage, guard, risk, inflexibility, data.isFeint, data.isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
    let overFlow = updateRisk > 100 ? updateRisk - 100 : 0;


    const updates = { "system.defense.guard.value": await this.calculateGuard(damage + overFlow, guard, data.isFeint, data.isStrongAttack, action, attackingActorParryCounter, attackingActorFeint), "system.defense.risk.raw": updateRisk };
    await this.update(updates);
    await this.renderAttackResultCard(data, action);
    await this.activateDamageTakenSkill();
    return this;
  }

  async activateDamageTakenSkill(damage) {
    this.items.filter(i => i.type === "skill").filter(s => s.system.activateOnDamageAccept).forEach(async s => {
      await handleSkillActivate(this, s, false);
    })
  }

  async takeEffect(data) {
    await this.takeActionUpdates(data);
    await this.takeActionWounds(data);
    await this.takeActionResources(data);

    await handleSkillsGrantedOnAccept(data, this);
  }

  async takeAttack(data, action) {
    await this.takeEffect(data);
    await this.takeDamage(data, action);
  }

  async takeFinisher(rolls, data, finisherType) {
    if (data.totalSuccesses < 1 && !this.statuses.has('offGuard')) {
      await this.sendFinisherToChat();
      return;
    }

    await this.takeEffect(data);
    await this.takeDamage(data, "finisher");

    const risk = this.system.defense.risk.raw;
    const totalRisk = this.applyModifiersToRisk(rolls, data, finisherType);
    let finisherCost = 0;
    let finisher = null;
    const uniqueFinisher = data.finisher ? Object.values(data.finisher)[0] : null;
    if (uniqueFinisher?.type && uniqueFinisher?.text) {
      const finisherConstruct = data.finisher;
      const availableFinishers = Object.entries(finisherConstruct).filter(e => e[1].type === finisherType).reduce((result, e) => { result[e[0]] = e[1]; return result }, {});
      finisherCost = this.getFinisherCost(availableFinishers, totalRisk, data.attackProfile);
      finisher = this.getFinisher(availableFinishers, finisherCost);
    } else {
      const availableFinishers = this.getAvailableFinishersForDamageType(finisherType);
      finisherCost = this.getFinisherCost(availableFinishers, totalRisk, data.attackProfile);
      finisher = this.getFinisher(availableFinishers, finisherCost);
    }
    await this.sendFinisherToChat(finisher, finisherCost);
    if (finisher) {
      return await this.applyFinisher(risk, finisher, finisherCost);
    }
  }

  mergeDamageTakenForRound(damage) {
    const lastRoundReceived = this.flags.abbrew.combat.damage.lastRoundReceived ?? [];
    const totalRoundReceivedDamage = Object.entries([...lastRoundReceived, ...damage].reduce((result, damage) => {
      if (damage.damageType in result) {
        result[damage.damageType] += damage.value;
      } else {
        result[damage.damageType] = damage.value;
      }

      return result;
    }, {})).map(e => ({ damageType: e[0], value: e[1] }));

    return totalRoundReceivedDamage;
  }

  applyModifiersToRisk(rolls, data, finisherType) {
    let successes = 0;
    if (this.system.defense.protection[finisherType].immunity > 0) {
      return successes;
    }

    successes += data.totalSuccesses;
    successes += this.system.defense.risk.value;
    successes -= this.system.defense.inflexibility.resistance.value;
    successes -= Math.max(0, this.system.defense.protection[finisherType].resistance - (data.damage.find(d => d.damageType === finisherType)?.penetration ?? 0));
    successes += this.system.defense.protection[finisherType].weakness;
    successes += (data.actorSize - this.system.meta.size); // TODO Question, do we include this + (data.weaponSize - this.system.meta.size))
    successes += (data.actorTier - this.system.meta.tier.value); // TODO: Material Tier Diff    
    return successes;
  }

  getAvailableFinishersForDamageType(finisherType) {
    return finisherType in FINISHERS ? FINISHERS[finisherType] : FINISHERS['untyped'];
  }

  getFinisherCost(availableFinishers, risk, attackProfile) {
    const viableRisk = Math.min(risk, attackProfile.finisherLimit);
    const keys = Object.keys(availableFinishers);
    const cost = keys.filter((value) => value <= viableRisk).pop();
    if (cost) {
      return cost;
    }

    return 0;
  }

  getFinisher(availableFinishers, finisherKey) {
    return availableFinishers[finisherKey];
  }

  // TODO: Move to another module?
  async sendFinisherToChat(finisher, finisherCost) {
    const templateData = {
      finisherCost,
      finisher,
      actor: this,
      tokenId: this.token?.uuid || null,
    };

    const html = await renderTemplate("systems/abbrew/templates/chat/finisher-card.hbs", templateData);

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });
    // const rollMode = game.settings.get('core', 'rollMode');
    const label = finisher ? `${finisher.name}` : "No available finisher";
    ChatMessage.create({
      speaker: speaker,
      // rollMode: rollMode,
      flavor: label,
      content: html,
      flags: { data: { finisher, finisherCost } }
    });
  }

  async applyFinisher(risk, finisher, finisherCost) {
    const updates = { "system.wounds": mergeActorWounds(this, finisher.wounds), "system.defense.risk.raw": this.reduceRiskForFinisher(risk, finisherCost) };
    await this.update(updates);
    return this;
  }

  reduceRiskForFinisher(risk, finisherCost) {
    return risk - (finisherCost * 10);
  }

  applyModifiersToDamage(data) {
    let rollSuccesses = data.totalSuccesses;
    return data.damage.reduce((result, d) => {
      const allProtection = this.system.defense.protection["all"];
      const protection = this.system.defense.protection[d.damageType];
      if (protection.immunity > 0 || allProtection.immunity > 0) {
        return result;
      }

      const damageTypeSuccesses = rollSuccesses;

      if (damageTypeSuccesses < 0) {
        return result;
      }

      let multiplierSelector = allProtection.resistance + Math.max(0, protection.resistance - d.penetration) - (protection.weakness + allProtection.weakness);
      let multiplier = 1;
      if (multiplierSelector > 0) {
        multiplier = 0.5;
      } else if (multiplierSelector < 0) {
        multiplier = 2;
      }

      const dmg = Math.floor(d.value * multiplier) + (protection.amplification + allProtection.amplification) - (protection.reduction + allProtection.reduction);

      return result += dmg;
    }, 0);
  }

  async calculateGuard(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    return guard - this.calculateGuardReduction(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
  }

  calculateGuardReduction(damage, guard, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    if (this.noneResult(isFeint, action)) {
      return 0;
    }

    if (isStrongAttack) {
      return 0 + damage;
    }

    if (this.attackerGainsAdvantage(isFeint, action)) {
      return getAttackerAdvantageGuardResult(this.system.skillTraining.find(st => st.type === "feintCounter")?.value ?? 0, attackingActorFeint, damage);
    }

    if (this.defenderGainsAdvantage(isFeint, action)) {
      return getDefenderAdvantageGuardResult(this.system.skillTraining.find(st => st.type === "parry")?.value ?? 0, attackingActorParryCounter, damage);
    }

    return 0 + damage;
  }

  calculateRisk(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    return risk + this.calculateRiskIncrease(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint);
  }

  calculateRiskIncrease(damage, guard, risk, inflexibility, isFeint, isStrongAttack, action, attackingActorParryCounter, attackingActorFeint) {
    if (this.noneResult(isFeint, action)) {
      return 0;
    }

    if (isStrongAttack) {
      return guard > 0 ? Math.min(damage, inflexibility) : damage;
    }

    if (this.attackerGainsAdvantage(isFeint, action)) {
      return getAttackerAdvantageRiskResult(this.system.skillTraining.find(st => st.type === "feintCounter")?.value ?? 0, attackingActorFeint, damage, inflexibility, guard);
    }

    if (this.defenderGainsAdvantage(isFeint, action)) {
      return getDefenderAdvantageRiskResult(this.system.skillTraining.find(st => st.type === "parry")?.value ?? 0, attackingActorParryCounter, damage, inflexibility, guard);
    }

    return guard > 0 ? Math.min(damage, inflexibility) : damage;
  }

  defenderGainsAdvantage(isFeint, action) {
    return isFeint === false && action === 'parry';
  }

  attackerGainsAdvantage(isFeint, action) {
    return isFeint === true && action === 'parry';
  }

  noneResult(isFeint, action) {
    return isFeint === true && action === 'damage'
  }

  async renderAttackResultCard(data, action) {
    const attackerAdvantage = this.attackerGainsAdvantage(data.isFeint, action);
    const defenderAdvantage = this.defenderGainsAdvantage(data.isFeint, action);
    const noneResult = this.noneResult(data.isFeint, action);

    const templateData = {
      attackerAdvantage,
      defenderAdvantage,
      noneResult,
      actor: this,
      defendingActor: this,
      attackingActor: data.attackingActor,
      tokenId: this.token?.uuid || null,
    };

    const html = await renderTemplate("systems/abbrew/templates/chat/attack-result-card.hbs", templateData);

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });

    ChatMessage.create({
      speaker: speaker,
      // rollMode: rollMode,
      // flavor: label,
      content: html,
      flags: { /* data: { finisher, finisherCost } */ }
    });
  }

  getActorWornArmour() {
    const armour = this.items.filter(i => i.type === 'armour');
    return armour.filter(a => a.system.equipState === 'worn')
  }

  getActorHeldItems() {
    return this.items.filter(a => a.system.equipType === 'held').filter(a => a.system.equipState.startsWith('held'));
  }

  getActorAnatomy() {
    return this.system.anatomy
  }

  doesActorHaveSkillTrait(feature, subFeature, effect, data) {
    return this.items.filter(i => i.system.skillTraits).flatMap(i => JSON.parse(i.system.skillTraits)).some(t => t.feature === feature && t.subFeature === subFeature && t.effect === effect && t.data === data) ?? false;
  }

  async acceptWound(type, value) {
    const updates = { "system.wounds": mergeActorWounds(this, [{ type, value }]) };
    await this.update(updates);
    return this;
  }

  async acceptBackground(background) {
    const name = background.name;
    const image = background.img;
    const description = background.system.description;
    const attributeIncreases = Object.entries(background.system.attributes).filter(atr => atr[1].value > 0).reduce((result, attribute) => result.concat(Array(attribute[1].value).fill(attribute[0])), []);
    for (const index in attributeIncreases) {
      const system = {
        description,
        attributeIncrease: attributeIncreases[index],
        skillType: "background"
      };
      const itemData = {
        name,
        img: image,
        type: 'skill',
        system
      };
      await Item.create(itemData, { parent: this });
    }
  }

  async acceptCreatureForm(creatureForm) {
    const anatomy = await Promise.all(creatureForm.system.anatomy.map(async a => await fromUuid(a.sourceId)));
    for (const index in anatomy) {
      await Item.create(anatomy[index], { parent: this });

      const weapons = await Promise.all(anatomy[index].system.naturalWeapons.map(async w => await fromUuid(w.sourceId)));
      for (const weaponIndex in weapons) {
        await Item.create(weapons[weaponIndex], { parent: this });
      }
    }
  }

  async acceptSkillDeck(skillDeck) {
    const skills = await Promise.all(skillDeck.system.skills.granted.map(async s => await fromUuid(s.sourceId)));
    await handleGrantedSkills(skills, this, skillDeck);
  }

  async acceptAnatomy(anatomy) {
    const naturalWeapons = await Promise.all(anatomy.system.naturalWeapons.map(async w => await fromUuid(w.sourceId)));
    for (const index in naturalWeapons) {
      await Item.create(naturalWeapons[index], { parent: this })
    }
  }

  async canActorUseActions(actions) {
    if (!game.combat && actions <= 5) {
      return true;
    }

    let remainingActions = this.system.actions;
    if (actions > remainingActions) {
      ui.notifications.info("You do not have enough actions to do that.");
      return false;
    }

    await this.update({ "system.actions": remainingActions -= actions });
    return true;
  }

  // TODO: Tidy this
  async handleDeleteActiveEffect(effect) {
    const itemId = effect?.flags?.abbrew?.skill?.trackDuration;
    if (itemId) {
      const item = this.items.find(i => i._id === itemId)
      if (item) {
        if (item.system.applyOnExpiry && item.isOwner) {
          await applySkillEffects(this, item);
        }
        await item.update({ "system.action.charges.value": 0 })
        if (item.system.skillType === "temporary") {
          await item.delete();
        }
        const effects = item.effects;
        const promises = [];
        effects.forEach(e => promises.push(e.update({ "disabled": true })));
        await Promise.all(promises);
      }
    }

    const activeSkillsWithDuration = this.effects.toObject().filter(e => e.flags?.abbrew?.skill?.type === "standalone").map(e => e.flags.abbrew.skill.trackDuration);
    const queuedSkillsWithDuration = this.effects.toObject().filter(e => e.flags?.abbrew?.skill?.type === "synergy").map(e => e.flags.abbrew.skill.trackDuration);
    await this.update({ "system.activeSkills": activeSkillsWithDuration, "system.queuedSkills": queuedSkillsWithDuration });
  }

  doesActorHaveSkillDiscord(skill) {
    if (skill) {
      return isSkillBlocked(this, skill);
    }

    return false;
  }

  async handleResourceFill(id, capacity) {
    const resourceValues = this.system.resources.values;
    resourceValues.find(r => r.id === id).value += capacity;
    await this.update({ "system.resources.values": resourceValues });
  }
}