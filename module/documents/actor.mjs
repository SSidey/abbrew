import { mergeActorWounds, renderLostResolveCard } from "../helpers/combat.mjs";
import { FINISHERS } from "../static/finishers.mjs";

/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export default class AbbrewActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    console.log('documentPrepareData');
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    console.log('documentPrepareBaseData');
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't 
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    console.log('documentPrepareDerivedData');
    const actorData = this;
    const flags = actorData.flags.abbrew || {};
  }

  /**
   * 
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic 
   * approach is useful when you have actors & items that share a parent Document, 
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
  }

  async takeDamage(rolls, data) {
    console.log('Got me');
    let guard = this.system.defense.guard.value;
    let risk = this.system.defense.risk.raw;
    const inflexibility = this.system.defense.inflexibility.value;
    // let activeWounds = this.system.wounds.active.value;
    // const maxGuardDamage = this.system.defense.protection.reduce((a, b) => {
    //   if (b.value > a) {
    //     a = b.value;
    //   }
    //   return a;
    // }, 1);

    // TODO: Pass Damage Types
    // TODO: Determine DRs by damage type

    // TODO: Do we still want this?
    // const guardBreak = rolls[0].dice[0].results[0].result > guard;
    // if (guardBreak) {
    //   totalSuccesses += 1;
    // }

    const damage = this.applyModifiersToDamage(rolls, data);

    // const wounds = activeWounds + damage;

    const updates = { "system.defense.guard.value": this.calculateGuard(damage, guard), "system.defense.risk.raw": this.calculateRisk(damage, guard, risk, inflexibility) };
    await this.update(updates);
    console.log('updated');
    return this;
  }

  async takeFinisher(rolls, data) {
    const risk = this.system.defense.risk.raw;
    console.log('Finisher');
    const totalRisk = this.applyModifiersToRisk(rolls, data);
    const availableFinishers = this.getAvailableFinishersForDamageType(data);
    const finisherCost = this.getFinisherCost(availableFinishers, totalRisk);
    const finisher = this.getFinisher(availableFinishers, finisherCost);
    console.log(finisher);
    await this.sendFinisherToChat(finisher, finisherCost);
    return await this.applyFinisher(risk, finisher, finisherCost);
  }

  applyModifiersToRisk(rolls, data) {
    const rollSuccesses = data.totalSuccesses;
    // Plate less guard, more risk reduction, leather more guard, less risk reduction
    // TODO: Size Diff
    // TODO: Tier Diff
    // TODO: Lethal Diff
    // TODO: Material Tier Diff
    return 0 + this.system.defense.risk.value + rollSuccesses;
  }

  getAvailableFinishersForDamageType(data) {
    return data.damage[0].damageType in FINISHERS ? FINISHERS[data.damage[0].damageType] : FINISHERS['general'];
  }

  getFinisherCost(availableFinishers, risk) {
    // TODO: Apply weapon size limit
    const keys = Object.keys(availableFinishers);
    return keys.filter((value) => value <= risk).pop();
  }

  getFinisher(availableFinishers, finisherKey) {
    return availableFinishers[finisherKey];
  }

  // TODO: Move to another module?
  async sendFinisherToChat(finisher, finisherCost) {
    const templateData = {
      finisherCost,
      finisher,
      actor: this,
      tokenId: this.token?.uuid || null,
    };

    const html = await renderTemplate("systems/abbrew/templates/chat/finisher-card.hbs", templateData);

    // Initialize chat data.
    const speaker = ChatMessage.getSpeaker({ actor: this.actor });
    // const rollMode = game.settings.get('core', 'rollMode');
    const label = `${finisher.name}`;
    ChatMessage.create({
      speaker: speaker,
      // rollMode: rollMode,
      flavor: label,
      content: html,
      flags: { data: { finisher, finisherCost } }
    });
  }

  async applyFinisher(risk, finisher, finisherCost) {
    const updates = { "system.wounds": mergeActorWounds(this, finisher.wounds), "system.defense.risk.raw": this.reduceRiskForFinisher(risk, finisherCost) };
    await this.update(updates);
    if (this.system.wounds.reduce((total, wound) => total += wound.value, 0) >= this.system.defense.resolve.value) {
      await renderLostResolveCard(this);
    }
    return this;
  }

  reduceRiskForFinisher(risk, finisherCost) {
    return risk - (finisherCost * 10);
  }

  applyModifiersToDamage(rolls, data) {
    let rollSuccesses = data.totalSuccesses;
    return data.damage.reduce((result, d) => {
      // TODO: Do we do damage reduction, or just give negations per DR?
      const protection = /* this.system.defense.protection.some(dr => dr.type === d.damageType) ? this.system.defense.protection.filter(dr => dr.type === d.damageType)[0] : */ { immunity: 0, resistance: 0, weakness: 0, value: 0 };
      if (protection.immunity > 0) {
        return result;
      }

      const firstRoll = rolls[0].dice[0].results[0].result ?? 0;
      // const dodge = this.system.defense.dodge.value;
      const damageTypeSuccesses = /* firstRoll > dodge ? */ rollSuccesses/*  + protection.weakness - protection.resistance : -1 */;

      if (damageTypeSuccesses < 0) {
        return result;
      }

      const dmg = /* damageTypeSuccesses == 0 ? Math.max(0, d.value - protection.value) : */ d.value;

      return result += dmg;
    }, 0);
  }

  calculateGuard(damage, guard) {
    return Math.max(0, guard - damage);/* Math.max(0, guard - maxGuardDamage); */
  }

  calculateRisk(damage, guard, risk, inflexibility) {
    const riskIncrease = guard > 0 ? Math.min(damage, inflexibility) : damage;
    return risk + riskIncrease;
  }
}
